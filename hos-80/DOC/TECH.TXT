-------------------------------------------------------------------------------
 HOS-80 Ver 0.00 Hyper Oparating System for Z80                                
 テクニカルドキュメント                                                        
                                                    Copyright (C) 1998 by Ryuz 
-------------------------------------------------------------------------------

  このドキュメントでは、HOS-80 のソースを読んだり、バグを取ったり、改造したり
する人のために少しでも役立ちそうなことを書いておきます。参考になれば幸いです。




------------------------------------------------------------------------------
                           ライブラリメイク
------------------------------------------------------------------------------
  ライブラリリンク時にマクロを宣言することで、エラーチェックを変更できます。


＜エラーチェックについて＞
  μITRONではさまざまなエラー項目が用意されていますが、極めて小さなシステム
では起こることが絶対に無いエラーをいちいちチェックするのはメモリも実行速度
も無駄となります。そこで HOS では __ERR_CHECK_LEVEL というマクロを用意しま
した。このマクロの値によってエラーチェックを外したライブラリが容易に作製で
きます。
  現バージョンでは E_QOVR, E_CTX, E_OBJ, E_ID, E_NOEXS, E_PAR の６つのエラー
に対処しております。__ERR_CHECK_LEVEL を小さい値にするほどチェックするエラー
項目が減っていきます。
  基本的に E_ID, E_NOEXS, E_PAR はプログラム時の人為的ミスでしか発生しない
と思います

4 : E_QOVR, E_OBJ, E_CTX, E_ID, E_NOEXS, E_PAR （全てチェック）
3 : E_QOVR, E_OBJ, E_CTX
2 : E_QOVR, E_OBJ
1 : E_QOVR
0 : エラーチェックなし

  なおバージョンアップによってこれらの値が変わる可能性は大いにありますので
ご注意ください。


  なお、ただでさえいい加減なデバッグは __ERR_CHECK_LEVEL=4 でしか行なって
おりません。




------------------------------------------------------------------------------
                       ソースを読まれる方のために
------------------------------------------------------------------------------

  ソースを読まれる方のために少しだけ説明を書いておきます。


＜オブジェクトのコントロールブロック＞
  タスク、セマフォ、イベントフラグ、メイルボックスなどのオブジェクトは全て
配列で管理しています。IDに 0 はありませんので、ID - 1 が配列上の位置となり
ます。ROM化されるべき初期値と、RAM上に置かれるべき作業領域とで別々の構造体
を用意しています。またアセンブリ部からアクセスされるものについてはなるべく
先頭の方に宣言しています。
  これらは全てコンフィギュレーターが吐くソースの中で宣言されます。

・タスクコントロールブロック(ID 1-n)
  T_TCB  tcbtbl[n];    RAM部
  T_TCBS tcbstbl[n];   ROM部
  UB     tcbcnt = n;   TCBの個数

・セマフォコントロールブロック(ID 1-n)
  T_SCB  scbtbl[n];    RAM部
  T_SCBS scbstbl[n];   ROM部
  UB     scbcnt = n;   SCBの個数

・イベントフラグコントロールブロック(ID 1-n)
  T_FCB  fcbtbl[n];    RAM部
  T_FCBS fcbstbl[n];   ROM部
  UB     fcbcnt = n;   FCBの個数

・メイルボックスコントロールブロック(ID 1-n)
  T_MCB  mcbtbl[n];    RAM部
  T_MCBS mcbstbl[n];   ROM部
  UB     mcbcnt = n;   MCBの個数

  サイズについてはあまり考慮していませんが、Z80には乗算命令がありませんので
2^n にすると高速化されるようです。exinf など必要無ければ省けばサイズの縮小
になります。なお属性(tskatrとか)の項目はありません。コプロはありませんし、
ルーチンは全てＣ言語とみなします。



＜レディーキュー＞
  レディーキューもコンフィギュレーターが出力します。優先度の数だけキューを
作りますので、必要な分だけをここで確保します。

  T_QUE rdyque[8];   レディーキュー (TSKPRI - 1 に対応)
  UB    rdqcnt = 8;  最大優先度

  レディーキューには RUN 状態のタスクも接続し、SUSPEND 状態のタスクは外し
ます。高優先度のキューから先頭だけを見ていき最初に見つけたタスクが現在の
タスク（curtcbが指すタスク)で無ければディスパッチが遅延されていると見なし
ます。


＜システムの状態 sysstat＞
  現在の状態を表すために sysstat というグローバル変数があります。この変数に
よってタスク部／非タスク部、ディスパッチの許可／不許可を管理します。


＜現在のタスク curtcb＞
  現在実行中のタスクの TCB を指す変数として curtcb があります。


＜遅延ディスパッチフラグ dlydsp＞
  ディスパッチ禁止中にディスパッチの要求があるとこのフラグを TRUE にします。
ディスパッチが許可された時点でこのフラグが TRUE であるとレディーキューの
先頭タスクにディスパッチしてフラグを FALSE にします。


＜ＨＡＬＴについて＞
  実行するタスクが無い場合は

  JR $

  を実行しています。HALTでもいいのですが、TMPZ84C015BFなどの周辺LSIを含んだ
ワンチップマイコンではHALTで周辺LSIをサスペンド出来ます。タイマなどが止まっ
てしまうと支障をきたす場合がありますので避けました。必要であれば変更してくだ
さい。



＜関数名・変数名＞
  ＯＳが内部で使っている関数についてはアンダースコア２つ "__" から始めるよう
にしていますが、変数については特に規則がありません。ＯＳ自体をオブジェクト化
しているのでこれらは static 属性にはなっていません。アプリケーション側で同じ
名前の変数を定義すると衝突してしまうので注意してください。
